<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<meta name="keywords" content="RZX,Ramsoft,ZX Spectrum,Speccy,Sinclair,tech,air,input,recording,library">
<title>WWR - RZX technical specifications</title>
<basefont face="Verdana">
<script async="" src="WWR%20-%20RZX%20technical%20specifications_files/js.js"></script><script async="" src="WWR%20-%20RZX%20technical%20specifications_files/wosc.html"></script></head>
<body vlink="#800080" text="#000000" link="#0000FF" bgcolor="#FFFFFF" alink="#FF0000">
<center>
<table width="50%" border="0" bgcolor="#0040ff">
<tbody><tr>
<td align="center">
<font size="+4" color="#ffff40"><strong>RZX FORMAT</strong></font>
</td>
</tr>
</tbody></table>
<br>
<em>
<font size="-1">Created by Ramsoft ZX Spectrum demogroup et al.</font>
</em>
<br><br><br>
<font size="+1"><strong>Format revision: v0.13 (March 2nd 2005)</strong></font>
</center>
<br><br><br>
<div align="center">
<table width="40%">
<tbody><tr>
<td align="LEFT">
<ol>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#INTRODUCTION">Introduction</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#LOGIC">Recording logic</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#SECURITY">Security</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#API">Programming interface (SDK)</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#RZXFORMAT">RZX file format</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#LICENSE">License and credits</a></b></li>
<li><b><a href="https://worldofspectrum.net/features/RZXformat.html#HISTORY">Revision history</a></b></li>
</ol>
</td>
</tr>
</tbody></table>
</div><br><br>
<a name="INTRODUCTION"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
1.
</b></font>
</td>
<td>
<font size="+2">
Introduction
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
The RZX format provides a standard method to record input events (such as keypresses and joystick
movements) in Spectrum emulators, and store them into files which can be later played back to reproduce
exactly the same actions. It is pretty much like recording the script of a movie and then having the
actors play it again exactly in the same way each time you watch it. For example, it is possible to
record the complete solution of a game or take part in internet game competitions.<br><br>
The RZX standard has been designed to overcome the limitations of other similar formats like AIR. AIR
files became quite popular with RealSpectrum and ASCD, but they had the major disadvantage of
non-portability, i.e. the files recorded by an emulator could not be played back by other emulators.
This happened because the recording logic was very sensitive to emulation timings, and for several
reasons each emulator currently has its own implementantion of the core timings (memory contention and
so on). Besides, the closed-source policy of the format actually limited its diffusion further.<br><br>
The main goals of the RZX project are:
<ul>
<li><strong>Portability.</strong><br>
Timing-independent recording logic for maximum compatibility with different
core implementations amongst different emulators; open-source policy; portable
C code using standard library functions (possibly ANSI-compliant) to
accomodate different platforms.
</li>
<li><strong>Easy implementation in emulators.</strong><br>
Adding RZX support to already existing emulation cores simply requires a few minimal changes.
The programmer is not required to change the way the emulator reads the keyboard and joystick by
adopting an invasive application interface. The internal state variables of the RZX logic are
very limited and it does not cost any performance penalties for the emulator.
</li>
<li><strong>Reduced file sizes.</strong><br>
RZX files are compressed in order to be easily distributed and shared on the net. Zlib will
probably be used for the purpose because it is highly portable.
</li>
<li><strong>Robust security.</strong><br>
Files destined to game tournaments are protected by a robust encoding system to prevent hacking
while preserving portability and open source principles.
</li>
</ul>
</td>
</tr>
</tbody></table>
</p>
<a name="LOGIC"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
2.
</b></font>
</td>
<td>
<font size="+2">
Recording logic
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
Several theories have been proposed and discussed by many people to obtain
input recording files that can be replayed on all emulators. The first way you
can think of to achieve that is to count the number of t-states between each
keypress; this is obviously the most simple approach, but the resulting files
would be replayed correctly only by the emulator used to record them. Why?
The ZX Spectrum machines (including the ones produced by Amstrad) are built in
a way that access to some memory areas is somewhat "contended" between the CPU
and the video circuitry - the latter having precedence as it cannot miss data
to build the video signal. This means that when the CPU and the video chip try
to access the same memory area at the same time, the CPU is slowed down so
that instructions effectively take longer to execute. The mechanism that
handles the CPU slowdown is partially documented and since various emulators
implement it in different ways, this obviously causes different behaviours
and could lead to undesired effects on games where
events are generated by pseudo-random counters, as they rely on R register or
internal frame counters. For this reason, every technique based on timing
events in t-states will fail in terms of portability.
<br><br>
The RZX engine is based on recording the input information at the end of the
frame together with the number of CPU instruction fetches that have been performed in that frame. When
replaying, the emulator will read both the number of fetches
to perform in the frame to be executed and the keyboard/joystick input, which will be valid for that
number of instructions, and then will force an interrupt when the
limit is reached. In very simple words, the RZX algorithm will say that the
input data you read will be valid for a given number of instruction fetches;
note that the fetch counter stepping is the same as the R register, i.e. it is incremented
by 1 for single-opcode instructions and by 2 for double-opcode ones. The interrupt acknowledge cycle is
NOT considered a regular instruction fetch, and thus it does not increment the fetch counter.
This method ensures absolute compatibility between emulators, no matter how
accurate they are. Besides, no rules are imposed concerning the way the emulator which records the RZX
acquires and updates the keyboard and joystick data, since the RZX logic guarantees that the same input
sequence will be perceived also by the playback application - and that's the only thing that actually
matters.
<br><br>
The following diagrams show what the emulator should do in order to take
advantage of the new recording format:
<br><br>
<div align="center">
<img src="rzxdiag.png" border="0">
</div>
<br><br>
The actual input data recording is achieved by logging the result of all the I/O port reads performed by
the CPU in a frame. During input recording, the RZX system records the values returned by the IN
instructions executed by the CPU; when the RZX file is replayed, these values are given back to the CPU
so that the port reads will return the same results as occurred during recording. The RZX design ensures
that each IN instruction gets exactly the right value as expected.<br>
This technique not only achieves input recording functionality, but it also solves many problems arising
from the differences between emulators. The most important of these issues is the floating bus, i.e. the
values fetched from the bus when a non-existent I/O port is read by the CPU. Other situations covered
are tape and disk loading (e.g. with multiload games) and accesses to I/O devices in general. For
example, any emulator can correctly replay an RZX file where the Kempston mouse and the lightgun have
been used - no matter if it doesn't emulate these devices at all!
<br><br>
<strong>
<font size="+1">Critical rules</font>
</strong>
<br><br>
<li><strong>Good CPU emulation.</strong><br>
A faithful emulation of the Z80 is a basic requirement for the RZX engine to
work properly. As you might imagine, the timings aspect is not important: we
said that the RZX format doesn't care about that, neither contention nor exact
instruction duration. A "proper" emulation must instead cover all known CPU
aspects, both documented and undocumented: a missing flag alteration can
result in a different branch of a program on some cases, thus leading to
different behaviours when replaying a file on different emulators. A famous example is the rhino's
behaviour in Sabre Wulf, as reported even in the Z80 emulator documentation - quoting:<br><br>
<i>
"The rhino in Sabre Wulf walks backward or keeps running in little circles in
a corner, if the (in this case undocumented) behaviour of the sign flag in the
BIT instruction isn't right. I quote:</i>
<br><br>
<pre>AD86    DD CB 06 7E        BIT 7,(IX+6)
AD8A    F2 8F AD           JP P,#AD8F
</pre>
<i>An amazing piece of code!"</i>
<br><br>
</li><li><strong>INT retriggering</strong><br>
This is a quite rare event: it usually happens when the handling routine
enables interrupts immediately (or a few t-states) after it has been called.
The INT retriggering probability varies between the various Spectrum models
and clones depending on the INT signal duration and might hardly affect correct
playback; a possible solution to avoid ambiguities could be to store the INT
signal duration in the recording block header so that the emulator can handle it
on its own. Unfortunately this is not enough when working on machines that have a
different contention mechanism, for example the ZS Scorpion: in this case memory
contention is applied at anytime and not only when building the video output, so
delay can occur even around the frame-cross instant altering the retrigger probability.
The only way to have a perfect trace of what has happened at record time is to insert
a frame record even when a retrigger occurs.
<br><br>
Example: the Z80 is set on IM2, interrupts are enabled and emulator sets INT
low for 48 T; the interrupt handler routine is a simple EI - RET.
<br><br>
<pre>                        T-STATES   Instruction  Cycle
                        =============================
                        - 70906:        NOP     (t0)
                        - 70907:         *      (t1)
INT signal goes LOW -&gt;  -     0:         *      (t2)
                        -     1:         *      (t3) &lt;- INT is sampled here
                        -     2:        INT acknowledgment: IFFs are reset
                        ...             (19 T-states for IM2)
                        -    21:        EI      (t0) &lt;- the INT handler
                        -    22:         *      (t1)    sets IFFs immediately
                        -    23:         *      (t2)
                        -    24:         *      (t3) &lt;- INT is not sampled!
                        -    25:        RET     (t0)
                        -    26:         *      (t1)
                        ...
                        -    34:         *      (t8)
                        -    35:         *      (t9) &lt;- INT is resampled here!
                        -    37:        INT acknowledgment IFFs are reset
                        ...             (again 19 T-states)
INT signal goes HIGH -&gt; -    48:         *           &lt;- 11th T-state of INTACK
                        ... 
                        -    56:        EI      (t0) &lt;- INT handler restarts
                        -    57:         *      (t1)    
                        -    58:         *      (t2)
                        -    59:         *      (t3) &lt;- INT is not sampled!
                        -    60:        RET     (t0)
                        -    61:         *      (t1)
                        ...
                        -    68:         *      (t8)
                        -    69:         *      (t9) &lt;- INT is resampled here!
                        ...             Program continues normally
</pre>
In this case the interrupt routine is called 2 times in a frame; it's obvious
that if the INT signal is low for 69 T-states or longer, the routine will be
triggered 3 times or more.
<br><br>
The RZX algorithm covers this
particular case without any problem, and there's no need to include any information
about the INT signal as every INT trigger will cause another record write in the file:
for each possible branch in the program caused by an
INT the algorithm will provide full information so that the emulator will
reproduce the exact instruction sequence. If needed, emulators can detect INT-retriggered frames by
checking whether the instruction counter is too small for a regular frame; for the Spectrum
computers, we suggest to check for a counter value less or equal to 4.
</li></td>
</tr>
</tbody></table>
</p>
<a name="SECURITY"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
3.
</b></font>
</td>
<td>
<font size="+2">
Security [obsolete info, needs updating to DSA]
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
One of the main applications for the RZX format is represented by game competitions. In such events,
players record their attempts at the assigned games into RZX files, which are then submitted to the
competition jury for evaluation and ranking. It is easy to see that security is a key feature in order
to prevent any sort of cheating and to ensure fair play in the competition. So, two classes of RZX files
exist: protected (to be used whenever security is required, e.g. for game competitions) and unprotected
(for general purposes like recording game solutions, etc). This chapter describes the security mechanism
used in protected RZX files.
<br><br>
As far as RZX security is concerned, the main points are:
<ul>
<li>Use of encryption techniques to protect against file hacking.</li>
<li>Possible control over the number of legal attempts.</li>
<li>Additional checks such as emulation speed violations, autofire detection, etc.</li>
</ul>
To ensure data protection despite the encryption algorthm being available in source code form, we use a
combination of symmetric and asymmetric cryptography. In the next paragraph we recall a few basic
concepts about cryptographic algorithms, in very simple words:
<ul>
<li>In <strong>symmetric algorithms</strong>, the same key is used both for encryption and
decryption. A very simple example is XOR scrambling, where the data to protect is bitwise XORed
with a certain sequence of bits (bytes) of a given length. This approach isn't suitable for our
purpose alone because the key would necessarily be public and so it could be easily used for
hacking. A popular symmetric algorithm is DES.</li>
<li>In <strong>asymmetric algorithms</strong>, a couple of complementary keys is used; the
<em>public key</em> is made freely available to the public, while the <em>private key</em> is
not shared. Data encrypted using a certain public key can be decrypted only with the
corresponding private key, meaning that only the owner of that private key can read the message.
The only possible attack is brute force (i.e. trying to guess the secret key by exhaustive
enumeration), which takes ages even with the most powerful supercomputers available today.<br>
The drawback is that these techniques are usually computationally intensive, so they are not
suited for a real-time environment such as an emulator. A famous asymmetric algorithm is RSA.
</li>
</ul>
In a typical RZX scenario, the competition jury generates a couple of asymmetric keys, referred to as
the public key (<b>p-key</b>) and the secret key (<b>s-key</b>). The public key is made available for
download on the competition website, while the secret key is kept in the vault. Besides, another couple
of asymmetric keys is associated to each emulator.<br><br>
Now let's see how the RZX security system actually works.
To ensure good performances, we use a symmetric algorithm to encrypt the input recording data, e.g.
XORing the data with a 128-bit key (<b>x-key</b>) with a few additional tricks to increase confusion.
Whenever a new RZX file is created, the emulator generates a new random x-key to be used for that file
only (session key); then it uses the p-key of the competition (previosely downloaded by the player) to
encrypt the x-key using an asymmetric
algorithm, and then the encrypted x-key is finally stored into the RZX file itself.
<br><br>
Mathematical properties of asymmetric algorithms guarantee that only the owner of the s-key (i.e. the
jury itself) will be able to decode the x-key contained into the RZX file, which is necessary to decrypt
the input recording data. The encrypted RZX file is unreadable for anyone but the jury, and of course
any attempt to edit the file results in irreversible data corruption. If desired, the jury can
subsequently unlock the received files so that they can be redistributed and played back by anyone; this
is accomplished by means of a library function which simply decrypts the x-key contained into the RZX
file, so that the s-key will not be necessary anymore.
<br><br>
The next step is to guarantee that the encrypted RZX file has been generated by a trusted copy of an
emulator. Some sort of authentication is required for the source emulator too, so that the competition
jury can be sure that the received RZX file has not been illegally produced by, say, a custom
(unofficial) build of an open source emulator, specifically modified to allow cheating. This is
accomplished by means of electronic signature. The trusted emulator signs the RZX file by computing a
hash function (such as MD5) over the original RZX data; this hash value is then encrypted using the
secret key of the emulator and stored into the RZX file. When the recording is examined by the jury, the
RZX library decrypts the file, recomputes the hash value for the received data and compares it with the
one stored by the emulator. If they are the same, the RZX file is certified to have been produced by the
trusted emulator, and its contents is unaltered, otherwise it's a fake.<br>
The weak point is that the no safe vault exists for the emulator to keep it secret key in. The key must
be probably stored inside the program itself, so it is potentially vulnerable to reverse engineering of
the binary files. Once the malintentioned user obtains the secret key of the emulator, nothing can
prevent him to produce arbitrary RZX files which cannot be distinguished from trusted ones.
Unfortunately it is very difficult, if not impossible, to give general directions to emulator authors to
prevent reverse engineering. All the best must be done to make it as difficult as possible.
<br><br>
A detailed proof for the method exposed involves several mathematical theorems concerning cryptography,
and so it goes beyond the purpose of this document. Here it will be enough to mention that a similar
approach is used in commercial environments and in the PGP package.
<br>
Note that the asymmetric encoding performance is not a problem because the data to encode/decode is very
short (the x-key is only a few bytes) and it only happens when the RZX file is opened or created (i.e.
outside the emulation runtime).
<br><br>
In conclusion, the adoption of a mixture of symmetric and asymmetric cryptography ensures good
performances and rock-solid security, despite the algorithms used being freely available to everybody.
With regards to implementation details, we will provide the full source code of the proposed scheme,
including the symmetric/asymmetric algorithms and key generators.
<br><br>
In some cases the competition may allow a maximum number of attempts for each player. The RZX system
uses an unique session ID for each recording.
<br><br>
Additional security features offered by the library are:
<ul>
<li>Speed violation detection: the emulator ensures that the emulation speed stays within the
allowed range, e.g. 50 +/- 5 fps (10% tolerance).</li>
<li>Autofire detection: an heuristic algorithm is used to detect the use of autofire.</li>
</ul>
Some of these features will be available to juries only, e.g. the autofire detection. Such features will
be enabled by the presence of a special s-key on the system released by emulator authors.
</td>
</tr>
</tbody></table>
</p>
<a name="API"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
4.
</b></font>
</td>
<td>
<font size="+2">
Programming interface (SDK)
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>
 
<td>
The RZX SDK consists in an open-source library written in portable C code providing all the necessary
functions to add RZX support to your emulator. It is made available as a fast way to get RZX
functionality in your work, but of course you can use your own implementation of the RZX system, if you
prefer.
<br>
The latest version of the SDK can be downloaded from the RZX official homepage. It has been tested on
GCC (Linux and DJGPP) and Visual C++ 6. The code is endian-independent, so it will work on non-Intel
platforms too. Check out the include file for some compile options.
<br><br>
<b>int rzx_init()</b><br>
Initializes the RZX library. It must be called before any other RZX function.
<br><br>
<b>int rzx_update(rzx_u16 *icount)</b><br>
In playback mode, this function is called to start a new frame (the new icount is supplied). In
recording mode, it writes the current frame (which is icount instructions long) to the RZX file and it
is called when an interrupt occurs (or it would occur, if maskable interrupts are disabled).
<br><br>
<b>rzx_u8 rzx_get_input(void)</b><br>
Supplies the result for IN instructions performed by the CPU. This function must be called in playback
mode only.
<br><br>
<b>void rzx_store_input(rzx_u8 value)</b><br>
Writes the result returned by a CPU IN instruction to the RZX file. This function must be called in
recording mode only.
<br><br>
<b>int rzx_close()</b><br>
Closes the RZX file. Must be called when the recording is finished. It is called automatically at the
end of playback.
<br><br>
<b>int rzx_add_snapshot(const char *filename, const dword flags)</b><br>
Stores a snapshot into the RZX.
</td>
</tr>
</tbody></table>
</p>
<a name="RZXFORMAT"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
5.
</b></font>
</td>
<td>
<font size="+2">
RZX file format
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
<div align="center">
<table width="50%" cellspacing="2" cellpadding="4" border="1" bgcolor="#8080D0">
<tbody><tr bgcolor="#8080D0">
<td colspan="2" align="center">
<font size="+1" color="#FFFFFF"><b>Legenda</b></font>
</td>
</tr>
<tr bgcolor="#f7f7ff">
<td width="30%" align="center">WORD</td>
<td>2 bytes</td>
</tr>
<tr bgcolor="#f7f7ff">
<td align="center">DWORD</td>
<td>4 bytes</td>
</tr>
<tr bgcolor="#f7f7ff">
<td align="center">BYTE[N]</td>
<td>N bytes</td>
</tr>
<tr bgcolor="#f7f7ff">
<td align="center">ASCII[N]</td>
<td>N ASCII characters</td>
</tr>
<tr bgcolor="#f7f7ff">
<td align="center">ASCIIZ[N]</td>
 <td>ASCII string with zero-padding to N bytes total</td>
</tr>
<tr bgcolor="#8080D0">
<td colspan="2">
<font color="#FFFFFF">All multi-byte values are stored in Intel byte order
(little-endian).<br>
All <em>reserved</em> or undefined bits must be set to zero.
<br>
All the headers fields must be filled in; blank values are not allowed.</font>
</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">RZX Header</font>
</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">RZX global file header - <strong> status: <font color="#ff6060">required</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">"RZX!"</td>
<td align="center">ASCII[4]</td>
<td>RZX signature (hex 0x21585A52)</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x04</td>
<td align="center">0x00</td>
<td align="center">BYTE</td>
<td>RZX major revision number</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">0x0D</td>
<td align="center">BYTE</td>
<td>RZX minor revision number</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x06</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Flags<br>
<font size="-2">
b0: if set, all data following the main header and up to the Security Signature
Block is signed.
</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x0A</td>
<td align="center">-</td>
<td align="center">-</td>
<td>RZX blocks sequence</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Creator information block</font>
 </strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Information about the program which created the RZX -
<strong> status: <font color="#ff6060">required</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">0x10</td>
<td align="center">BYTE</td>
<td>Block ID</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x01</td>
<td align="center">29+N</td>
<td align="center">DWORD</td>
<td>Block length</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">-</td>
<td align="center">ASCIIZ[20]</td>
<td>Creator's identification string<br>
<font size="-2">(e.g. "RealSpectrum")</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x19</td>
<td align="center">VMAJ</td>
<td align="center">WORD</td>
<td>Creator's major version number</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x1B</td>
<td align="center">VMIN</td>
<td align="center">WORD</td>
<td>Creator's minor version number</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x1D</td>
<td align="center">-</td>
<td align="center">BYTE[N]</td>
<td>Creator's custom data (may be absent)</td>
</tr>
</tbody></table>
<table width="70%" border="0">
<tbody><tr>
<td>
<font size="-2">The identification string is freely determined by the emulator's author.
</font>
</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Security information block</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Security parameters for the following recording blocks -
<strong> status: <font color="#30a030">optional</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">0x20</td>
<td align="center">BYTE</td>
<td>Signature information block ID</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x01</td>
<td align="center">13</td>
<td align="center">DWORD</td>
<td>Block length</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Key ID<br>
<font size="-2">
The lower 32 bits of the DSA public key value <b>y</b>
</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x09</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Week code (e.g. for game tournaments)</td>
</tr>
</tbody></table>
<table width="70%" border="0">
<tbody><tr>
<td>
<font size="-2">As a general rule, data are encrypted <em>after</em> compression.</font>
</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Security signature block</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Signature block for the following recording blocks -
<strong> status: <font color="#30a030">optional</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">0x21</td>
<td align="center">BYTE</td>
<td>Signature block ID</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x01</td>
<td align="center">5+LR+LS</td>
<td align="center">DWORD</td>
<td>Block length</td>
</tr>
 <tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">-</td>
<td align="center">BYTE[LR]</td>
<td>Parameter <b>r</b> of the DSA signature<br>
<font size="-2">
The value is stored in OpenPGP format, see RFC 2440 section 3.2 (multi-precision
integers)
</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05+LR</td>
<td align="center">-</td>
<td align="center">BYTE[LS]</td>
<td>Parameter <b>s</b> of the DSA signature<br>
<font size="-2">
The value is stored in OpenPGP format, see RFC 2440 section 3.2 (multi-precision
integers)
</font>
</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Snapshot block</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Snapshot block - <strong> status: <font color="#30a030">
optional</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td width="15%" align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">0x30</td>
<td align="center">BYTE</td>
<td>Snapshot block ID</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x01</td>
<td align="center">17+SL</td>
<td align="center">DWORD</td>
<td>Block length</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Flags<br>
<font size="-2">
b0: External Data (this block contains a snapshot descriptor structure instead of
the snapshot image).<br>
b1: Compressed data.
</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x09</td>
<td align="center">-</td>
<td align="center">ASCIIZ[4]</td>
<td>Snapshot filename extension ("SNA", "Z80", etc).<br>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x0D</td>
<td align="center">USL</td>
<td align="center">DWORD</td>
<td>Uncompressed snapshot length (same as SL is the snapshot is not compressed).</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x11</td>
<td align="center">-</td>
<td align="center">BYTE[SL]</td>
<td>Snapshot data or descriptor.<br>
</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Snapshot descriptor</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Payload of the Snapshot Block when the External Data
flag is set.</font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Checksum (0 = ignore)</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x04</td>
<td align="center">-</td>
<td align="center">ASCIIZ[N]</td>
<td>Snapshot filename</td>
</tr>
</tbody></table>
<br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">Input recording block</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Actual input recording data - <strong> status: <font color="#ff6060">required</font>
</strong></font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">0x80</td>
<td align="center">BYTE</td>
<td>Recording block ID</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x01</td>
<td align="center">18+?</td>
<td align="center">DWORD</td>
<td>Block length (with compressed data)</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x05</td>
<td align="center">NF</td>
<td align="center">DWORD</td>
<td>Number of frames in the block.<br>
</td></tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x09</td>
<td align="center">0x00</td>
<td align="center">BYTE</td>
<td>Reserved.<br>
</td></tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x0A</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>T-STATES counter at the beginning</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x0E</td>
<td align="center">-</td>
<td align="center">DWORD</td>
<td>Flags<br>
<font size="-2">
b0: Protected (frames are encrypted with x-key).<br>
b1: Compressed data.
</font>
</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x12</td>
<td align="center">-</td>
<td align="center">FRAME</td>
<td>Sequence of input frames (compressed)</td>
</tr>
</tbody></table>
 <br><br>
<table width="70%" cellspacing="1" cellpadding="2" border="0" bgcolor="#000000">
<tbody><tr bgcolor="#80a0ff">
<td colspan="4" align="center"><strong>
<font size="+2" color="#ffffff">I/O Recording frame</font>

</strong></td>
</tr>
<tr bgcolor="#fff000">
<td colspan="4" align="center">
<font size="-2" color="#606060">Layout of the input log for this frame -
<strong>4</strong> + ?</font>
</td>
</tr>
<tr bgcolor="#ffdf90">
<td align="center"><strong>Offset</strong></td>
<td align="center"><strong>Value</strong></td>
<td width="15%" align="center"><strong>Type</strong></td>
<td align="center"><strong>Description</strong></td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x00</td>
<td align="center">IC</td>
<td align="center">WORD</td>
<td>Fetch counter till next interrupt (i.e. number of R increments, INTA excluded)<br>

</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x02</td>
<td align="center">IN</td>
<td align="center">WORD</td>
<td>IN counter. Number of I/O port reads performed by the CPU in this frame (their return
values follow). If equal to 65535, this was a repeated frame, i.e. the port reads were
exactly the same of the last frame.</td>
</tr>
<tr bgcolor="#c0f0ff">
<td align="center">0x04</td>
<td align="center">-</td>
<td align="center">BYTE[IN]</td>
<td>Return values for the CPU I/O port reads.<br>
</td></tr>
</tbody></table>
</div>
<br><br>
<strong>To be completed (Session Information Block, Comment Block).</strong>
<br><br>
Blocks are processed as <em>commands</em>, e.g. it is possible to include multiple recording blocks
separated by snapshot blocks to deal with multiload games, or change the security parameters, etc.
Everything is handled transparently by the RZX library functions.
</td>
</tr>
</tbody></table>
</p>
<a name="LICENSE"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
6.
</b></font>
</td>
<td>
<font size="+2">
License and credits
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
The RZX format is currently maintained by Ramsoft.<br>
The latest version of this document and the RZX SDK can be found at:
<ul>
<li><a href="https://worldofspectrum.net/features/RZXformat.html">https://worldofspectrum.net/RZXformat.html</a></li>
</ul>
<b>License</b><br><br>
Work in progress.
<br><br>
<b>Useful links and references for emulator authors</b><br><br>
<ul>
<li><a href="http://www.msxnet.org/tech/z80/">Z80 undocumented features</a> by Sean Young
</li><li><a href="http://www.geocities.com/SiliconValley/Peaks/3938/z80_home.htm">Z80 CPU Official
Support Page</a> by Thomas Scherrer
</li><li><a href="http://www.srcf.ucam.org/~pak21/cssfaq/index.html">Official ZX Spectrum FAQ</a>
maintained by Philip Kendall
</li><li><a href="https://worldofspectrum.net/features/TZXformat.html">TZX Specifications</a> v1.13 by Tomaz Kac
</li><li>Gerton Lunter's TECHINFO.DOC (accompanying Z80 v4.x emulator)
</li></ul>
<b>Thanks</b><br><br>
Work in progress.
</td>
</tr>
</tbody></table>
</p>
<a name="HISTORY"></a>
<p>
<table bbgcolor="#ffff90" width="100%" cellspacing="12" cellpadding="0" border="0">
<tbody><tr>
<td width="10%" bgcolor="#ff7848" align="center">
<font size="+2" color="white"><b>
7.
</b></font>
</td>
<td>
<font size="+2">
Revision history
</font>
</td>
</tr>
</tbody></table>
<br>
<table width="100%" border="0">
<tbody><tr>
<td width="10%"> </td>

<td>
<b>Revision 0.13 (March 2nd 2005)</b>
<ul>
<li>Added the security blocks, as already implemented in several emulators.</li>
<li>A few corrections and precisations along the document.</li>
</ul>
<b>Revision 0.12 DRAFT (Jul 30th 2002)</b>
<ul>
<li>Changed the idle frames marker from INcount=0 to INcount=65535.</li>
<li>Added a note about the R increment during interrupt ackowledge, which must not be counted.</li>
</ul>
<b>Revision 0.11 DRAFT (Apr 14th 2002)</b>
<ul>
<li>Experimental compression routines using ZLIB. Compression is used for recording data and
embedded snapshots. See the source code for comments and various defines. No error checking yet!
</li>
</ul>
<b>Revision 0.10 DRAFT (Apr 6th 2002)</b>
<ul>
<li>Changed the Frame Recording data format completely. Now it logs the I/O port read values instead
of storing the keyboard and joystick array; this is a more general approach which covers a lot
of nasty situations like the floating bus, tape/disk loading and possibly supports other I/O
devices.</li>
<li>Preliminary API description. Added new comments and explanations throughout all the document.
</li>
</ul>
<b>Revision 0.02 DRAFT (Feb 14th 2002)</b>
<ul>
<li>Changed the Input Recording Block and Creator Information Block headers slightly.</li>
<li>Added support for "idle frames": when bit 15 of the instruction counter is set, the input data
for that frame is omitted because it is the same as in the previous one. So, an idle frame takes
only 2 bytes in the RZX stream instead of 11.</li>
<li>Added electronic signature to the security system.</li>
<li>Added a note about floating bus in Chapter 2.</li>
<li>Revised Snapshot Block and new Snapshot Descriptor structure.</li>
</ul>
<b>Revision 0.01 DRAFT (Feb 2nd 2002)</b>
<ul>
<li>First public release of this document. Largely incomplete and buggy...</li>
</ul>
</td>
</tr>
</tbody></table>
</p>

</body></html>